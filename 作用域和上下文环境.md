# 作用域和上下文环境 #

### 什么是作用域：（只是维护自己范围内变量的集合） ###

 狭义上来说作用域就是一个对象（更确切的来说应该是集合）。

广义上来说作用域是一套用来存储变量，并且之后可以方便的找到这些变量的规则。

作用域负责收集并维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限javascript中最普遍的作用域是函数作用域。
 
### 什么是上下文环境： ###

代码（全局代码，函数体，eval代码）执行前的准备工作：
         
1.提升（变量 函数 函数表达式）

2.确定this指向 

3.与对应作用域关联  

如果代码段是函数体，那么在此基础上需要附加参数、赋值、arguments 赋值 。
        
可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量的值都在里面存储着 另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数。
 
### 作用域与执行上下文环境的关系： ###

一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）； 有可能有过，现在函数被调用完毕后，上下文环境被销毁了；
 
 
**示例**：

- 第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。      
      
- 第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。
      
- 第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。
      
- 第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下        文环境不能就此销毁，因为其中有闭包的引用。
    
- 第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(10)的上下文环境，并压栈，并设置为活动状态，但是此时fn(5)的上下文环境。还在内存中一个作用域下同时存在两个上下文环境。

## 执行上下文栈 ##

执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。
 
**示例**： 
    
- 第一，在执行代码之前，首先将创建全局上下文环境。赋上默认值。

- 第二，然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。

- 第三，跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。并将这个执行上下文环境压栈，设置为活动状态。
  
- 第四，执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境， 并压栈，设置为活动状态。

- 第五，待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完 了，就要及时销毁，释放内存）。

- 第六，同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁 （已经用完了，就要及时销毁，释放内存）。

## 变量的赋值操作 ##

var bigBady = "xfz";

**编译**：

按照正常情况，我们语言的编译器在遇到变量声明时最后会做的事情是：
为一个变量分配内存空间，将其命名为bigBady，赋上默认值undefined。

但是我们js引擎中的编译器处理会和预期不一样:

遇到var bigBady ;会询问当前作用域是否已经有一个该名称的变量。
——如果有，js引擎的编译器会忽略该声明，继续进行编译。
 ——如果没有，js引擎的编译器会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。

**运行**：

编译器最终会生成可以供引擎执行的代码，引擎在运行时会首先询问作用域，在当前作用域集合中是否存在着一个叫做bigBady 的变量 。
——如果有，js引擎就会使用这个变量。
——如果没有，js引擎就会去查找该变量（左/右查询）。
 
在javascript中变量的赋值操作会执行两个动作：

- 首先编译器声明变量。
- 其次引擎运行赋值。

这两步操作一上来都会要求作用域在当前作用域集合中去进行一次查找。

### 左查询与右查询 ###

在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

**非严格模式**：

RHS（右查询 ）在查询所有的嵌套作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError错误，但需要注意typeof时不会报错误（typeog 的安全机制）。
 
LHS（左查询）在查询所有的嵌套作用域中遍寻不到所需的变量，全局作用域中就会创建一个具有该名称的变量。

**严格模式**：

RHS,LHS都会抛出ReferenceError错误。

ReferenceError异常同作用域判别失败相关，TypeError则代表作用域判别成功了，但对结果的操作是非法或不合理的。

**左查询 **

赋值符号的左侧。

赋值操作的目标是谁。

要注意的是函数调用时实参与形参的关系就是一次左查询。

**右查询**

赋值符号的非左侧。

谁是赋值操作的源头。

## 提升（预解析） ##

在编译器执行编译阶段时有一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。

因此包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。这个过程我们称之为提升。
 
函数提升要优于变量的提升。

	<script>
		foo();// 1
		var foo = 2;
		function foo(){
			console.log(1);
		}

		/*预解析
		function foo(){
				console.log(1);
			}
		var foo；// foo已声明无法再次省声明

		逐行执行代码
		foo()；// 1
		foo = 2;
		*/

	</script>

变量的提升不会搭理if条件的暗示。
	
	<script>
		console.log(a);//undefined
		console.log(b);//undefined
		if(true){
			var a=2;
		}else{
			var b=4;
		}
	</script>

最佳实践：在块内部不要去定义函数。

	<script>
		console.log(test);// undefined
		console.log(test2);// undefined
		test();// TypeError: test is not a function 报错
		
		if(true){
			function test(){
				console.log("if");
			}
		}else{
			function test2(){
				console.log("else");
			}
		}
	</script>

注意区分函数表达式与函数声明的区别。
以function开头的具有函数的代码片段:函数声明。
不以function开头的具有函数的代码片段:函数表达式。

## 闭包 ##

什么是闭包：
当函数可以访问并记住自己所处的作用域链时，就会产生闭包。

闭包简单来说可以将一些不希望被外部看到的东西隐藏起来。

闭包是可以访问到外层函数变量的函数。

### 创建闭包的步骤 ###
1.函数的嵌套。

2.在内部函数中引用外部函数中的变量。

3.将内部函数传递出来。
- 通过return。
- 将函数赋值给一个全局变量window。
- 将函数设置为回调函数。

4.调用外部函数。
闭包可以延长变量的作用域链，可以将一些不希望被别人访问的变量隐藏起来。

### 闭包的生命周期： ###
1.闭包是什么时候创建的？闭包是在外部函数调用时创建的。

2.闭包是什么时候销毁的？内部函数销毁，则闭包销毁。

- 闭包的根本作用  延长变量的作用域。
- 创建闭包回导致变量长期在内存中存在，如果大量使用闭包会对内存有较大的消耗，所以在开发中不要大量使用闭包，在闭包使用完毕时，必须要将内层函数销毁。
 
闭包最常见的两个场景：函数作为返回值，函数作为参数传递。

	function foo() {
	    var a=2;
	    function bar(){
	       console.log(a);
	    }
	    bar();
	}
	foo();
	 
	function wait(msg){
	    setTimeout(function timer(){
	           console.log(msg);
	    },1000);
	} 